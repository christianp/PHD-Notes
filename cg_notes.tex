\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{upgreek}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{enumerate}
\usepackage{xr}
\usepackage[usenames,dvipsnames]{color}
\usepackage{setspace}
\usepackage{hyperref}
\singlespacing
%\onehalfspacing
%\doublespacing
%\setstretch{1.1}

\parskip 2ex
\parindent 0pt

\newcommand{\grz}[1]{$\mathcal{E}^{#1}$}	%grzegorczyk level

\newcommand{\NN}{\mathbb{N}}	%blackboard bold
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand\ov[1]{\overline{#1}} %overline
\newcommand{\maps}{\longrightarrow}

\newcommand\eps{\varepsilon}

\newcommand{\nth}{$n^{\textrm{th}}$~}	% nth and ith typeset nicely
\newcommand{\ith}{$i^{\textrm{th}}$~}
\renewcommand{\i}{\iota}
\renewcommand{\t}{\tau}

\newcommand{\shortlex}{{\sf ShortLex}\;}	% shortlex ordering has a sans-serif brand identity

\newcommand{\avec}{\mathbf{a}}	% vector
\newcommand{\bvec}{\mathbf{b}}	% vector 
\newcommand{\cvec}{\mathbf{c}}	% vector 
\newcommand{\dvec}{\mathbf{d}}	% vector 
\newcommand{\uvec}{\mathbf{u}}	% vector 
\newcommand{\vvec}{\mathbf{v}}	% vector 
\newcommand{\wvec}{\mathbf{w}}	% vector w
\newcommand{\xvec}{\mathbf{x}}	% vector x
\newcommand{\yvec}{\mathbf{y}}	% vector y
\newcommand{\zvec}{\mathbf{z}}	% vector 
\newcommand{\tvec}{\mathbf{t}}	% vector t
\newcommand{\Uvec}{\mathbf{U}}	% vector U
\newcommand{\psub}{\dot -}	% proper subtraction
\newcommand{\rsg}{\overline{sg}} % reverse signature
\newcommand{\recur}[1]{\begin{equation} \begin{split} #1 \end{split} \end{equation}}	%definition of recursive function
\newcommand{\recurN}[1]{\begin{equation*} \begin{split} #1 \end{split} \end{equation*}}	%ditto, no equation number

\newcommand{\classC}{$\mathcal{C}$}

\newcommand{\concat}{\ensuremath{+\!\!\!\!+\,}}	% list concatenation

\newcommand{\present}[2]{\left \langle #1 \: | \: #2 \right \rangle}	%group presentation
\newcommand{\fgoagog}{\pi_1(\mathbf{G},\Gamma,T,v_0)}	%fundamental group of a graph of groups
%universal group of a pregroup P
\newcommand{\UP}{\Uvec(P)}

%%% sets { ... | ... }
\newcommand{\set}[2]{\left\{\, \mathinner{#1}\vphantom{#2}\; \left|\; \vphantom{#1}\mathinner{#2} \right.\,\right\}}
\newcommand{\oneset}[1]{\left\{\, \mathinner{#1} \,\right\}}
\newcommand{\smallset}[1]{\left\{\mathinner{#1}\right\}}
%%%%%%%%%%%% brackets etc
\newcommand{\abs}[1]{\left|\mathinner{#1}\right|}
\newcommand{\floor}[1]{\left\lfloor\mathinner{#1} \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil\mathinner{#1} \right\rceil}
\newcommand{\bracket}[1]{\left[\mathinner{#1} \right]}
\newcommand{\parenth}[1]{\left(\mathinner{#1} \right)}
\newcommand{\gen}[1]{\left< \mathinner{#1} \right>}

\newcommand{\rdeg}[1]{\mbox{red-deg}\left(\mathinner{#1}\right)}
%%%%%%%%%%%%%functions
\newcommand{\find}{\operatorname{find}}
\newcommand{\Dfind}{\operatorname{Dfind}}
\newcommand{\Preduced}{\operatorname{Preduced}}
\newcommand{\leftm}{\operatorname{leftm}}
\newcommand{\Predn}{\operatorname{Predn}}
\newcommand{\Preduction}{\operatorname{Preduction}}
\newcommand{\Interleaven}{\operatorname{Interleaven}}
\newcommand{\GN}{\operatorname{GN}}
\newcommand{\+}{\:\hat +\:}
\newcommand{\¬}{\hat -}
\newcommand{\biggest}{\operatorname{biggest}}
\newcommand{\bigL}{\operatorname{bigL}}
\newcommand{\bigR}{\operatorname{bigR}}
\newcommand{\type}{\operatorname{type}}
\newcommand{\Egp}{\operatorname{Egp}}
\newcommand{\EgpA}{\operatorname{EgpA}}
\newcommand{\EgpB}{\operatorname{EgpB}}

\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]

\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}

\newenvironment{myproof}{\normalsize {\sc Proof}:}{{\hfill $\Box$}}

\newenvironment{cpe}{\noindent\color{OliveGreen} CP }{}
\newcommand{\cp}[1]{
\begin{cpe} #1 \end{cpe}}
%%
\newenvironment{ad}{\noindent\color{blue} AJD }{}
\newcommand{\ajd}[1]{
\begin{ad} #1 \end{ad}}
%%
\externaldocument[B-]{bass_serre_computability}
\begin{document}

\title{Notes on Cannonito and Gatterdam, Computability of group const.}
\author{Christian Perfect \and Andrew Duncan}
\maketitle

\section*{Theorem 3.1}
We shall define Cannonito and Gatterdam's 
 standard index of $F$ using the functions defined
in the Bass-Serre computability paper, as well as those defined, below. 
All references to equation numbers $<100$ are to the Basse-Serre paper.
\addtocounter{equation}{100} 

$J(x,y)$ is the  integer pairing function $J:\ZZ_{\geq 0} \times \ZZ \rightarrow \ZZ_{\geq 0}$ defined by 
\begin{equation}
J(x,y):=((x+y)^2+x)^2+y.
\end{equation}
This has ``left inverse'' $L$ and ``right inverse'' $R$ (called $K$ and
$L$ in \cite{Cannonito_1973}) given by
\begin{align}
R(x)&:=x\psub \lfloor x^{1/2}\rfloor^2 \textrm{ and}\\
L(x)&:=R(\lfloor x^{1/2}\rfloor)=\lfloor x^{1/2}\rfloor \psub \lfloor\lfloor x^{1/2} \rfloor^{1/2} \rfloor^2,
\end{align}
(where $\lfloor x^{1/2}\rfloor$ is the greatest integer $y$ such that 
$y^2<x$, and is defined in the Bass-Serre paper). 
The functions $J$, $L$ and $R$ satisfy 
\[LJ(x,y)=x\textrm{ and } RJ(x,y)=y\] 
and from \cite{Ritchie_1965} it follows that they are \grz{3}-computable.

For an integer $n$ define
\begin{equation} 
\bar n: = 2n, \textrm{ if } n\ge 0,\textrm{ and } -2n-1 \textrm{ otherwise}.
\end{equation}
To define the multiplication and inverse functions for  the free 
group it will be useful to have functions $\+$ and $\¬$ such that, 
$\overline{m+n}=\bar m \+ \bar n$ and $\overline{-n}=\¬ \bar n$.
These are defined, for $x,y\in \ZZ_{\geq 0}$,  by 
\begin{equation}
x\+ y :=
\begin{cases}
x+y &\textrm{ if } x \bmod 2=y \bmod 2=0 \\ 
x-y-1 &\textrm{ if } x \bmod 2=0, y \bmod 2=1 \textrm{ and } x\ge y+1\\ 
-x+y &\textrm{ if }  x \bmod 2=0, y \bmod 2=1 \textrm{ and } x< y+1\\ 
-x+y-1 &\textrm{ if } x \bmod 2=1, y \bmod 2=0 \textrm{ and } y\ge x+1\\ 
x-y &\textrm{ if } x \bmod 2=1, y \bmod 2=0 \textrm{ and } y< x+1 \\ 
x+y+1 &\textrm{ if } x \bmod 2=y \bmod 2=1
\end{cases}
\end{equation}
and 
\begin{equation}
\¬ x :=
\begin{cases}
0&\textrm{ if } x=0\\
x-1&\textrm{ if } x\neq 0\textrm{ and } x \bmod 2=0\\
x+1 &\textrm{ if } x\neq 0\textrm{ and } x \bmod 2=1
\end{cases}
.
\end{equation}
These are both \grz{3}-computable functions and have the required
properties. In particular $\bar m\+\bar n=0$ if and only if $m+n=0$.  

Let $F$ be free on a finite or  countable set $\{a_1,\ldots \}$. 
We identify $F$ with the set of reduced words on its generating set. 
Define
an index $i:F\maps \ZZ_{\geq 0}$ by 
\begin{align}
i(\emptyset)&:= 1\notag\\
i(a_{i_0}^{n_0}\cdots a_{i_r}^{n_r})&:=[J(i_0,\bar n_0),\ldots, J(i_r,\bar n_r)],\label{al:ifree}
\end{align}
for $r\ge 0$, $n_k\in \ZZ$, $n_k\neq 0$, 
and $a_{i_k}\neq a_{i_{k+1}}$, where $[\xvec]$ is defined in 
\eqref{B-eq:ntuple}. This is slightly different from the index defined in
\cite{Cannonito_1973}, where $J(i_k,\bar n_k)-1$ is used instead of
$J(i_k,\bar n_k)$; the difference arising because of the $+1$ in
\eqref{B-eq:ntuple}. 

Define the predicate $\GN$, which checks for the G\"odel number of 
a sequence of positive integers, by
\begin{equation}
\GN(\xvec) \iff 0\notin \xvec.
\end{equation} 
If $F$ is countably generated, by $\{a_1,\ldots \}$, then 
\[\xvec\in i(F)\iff \xvec=1 \vee [\GN(\xvec) \wedge \min_k\{R((\xvec)_k)=0\}=|\xvec|]. \]
If $F$ is generated by $\{a_1,\ldots, a_{n-1}\}$, we have 
\[\xvec\in i(F)\iff \xvec=1 \vee [\GN(\xvec) \wedge \min_k\{[L((\xvec)_k)>n-1]\vee [R((\xvec)_k)=0]\}=|\xvec|]. \]
Therefore $i$ is \grz{3}-decidable. 


To make the definition of $m$ easier to read, for an encoded list
$\xvec$ write $\xvec_\t$ for $L((\xvec)_{|\xvec|-1})$, $\xvec_\i$ for 
$L((\xvec_0))$, $n(\xvec)_\t$ for $R((\xvec)_{|\xvec|-1})$ and 
$n(\xvec)_\i$ for $R((\xvec_0))$ (so if $\xvec=i(a_{i_0}^{n_0}\cdots a_{i_r}^{n_r})$
then $\xvec_\i=i_0$, $\xvec_\t=i_r$, $n(\xvec)_\t=\bar n_r$ and $n(\xvec)_\i =\bar n_0$.)
Define
\begin{equation}\label{eq:mfree}
m(\xvec,\yvec) :=
\begin{cases}
 \xvec \concat \yvec& \textrm{ if } \xvec_\t\neq \yvec_\i\\
\xvec[0..|\xvec|-2]&\\
\quad\concat [J(\xvec_\t,\overline{n(\xvec)_\t}\+
\overline{n(\yvec)_\i})]&\\
\quad\quad\concat\yvec[1..|\yvec|-1]& \textrm{ if } \xvec_\t = \yvec_\i \wedge 
(\overline{n(\xvec)_\t}\+
\overline{n(\yvec)_\i}\neq 0)\\
m(\xvec[0..|\xvec|-2],\yvec[1..|\yvec|-1])& \textrm{ if }\xvec_\t = \yvec_\i \wedge 
(\overline{n(\xvec)_\t}\+
\overline{n(\yvec)_\i} =0)
\end{cases}
\end{equation}
and 

\begin{equation}\label{eq:jfree}
j(\xvec) :=j_1(\xvec,|\xvec|),
\end{equation} 
where 
\begin{align*}
j_1(\xvec,0) &:= 1 \textrm{ and }\\
j_1(\xvec, n+1) &:= 
\begin{cases}[J(L((\xvec)_n),\¬ R((\xvec)_n))]\concat j_1(\xvec,n)
& \textrm{ if } n+1\le |\xvec|\\
j_1(\xvec, n)& \textrm{ otherwise }
\end{cases}
\end{align*}
If $\xvec=i(u)$ and $\yvec=i(v)$, where $u$ and $v$ are reduced words 
in $F$ then $m(\xvec,\yvec)=i(uv)$ and $j(\xvec)=i(u^{-1})$, as required.
Also, $m$ and $j$ are \grz{3}-computable, as observed in \cite{Cannonito_1973},
since $m(\xvec,\yvec)\le \xvec \concat \yvec$ and \[j_1(\xvec)\le 
p_{|\xvec|}^{|\xvec|(J(\bigL,\bigR + 1)+1)},\]
where 
\[\bigL:=\biggest[L((\xvec)_0),\ldots, L((\xvec)_{|\xvec|-1})]\] and 
\[\bigR:=\biggest[R((\xvec)_0),\ldots, R((\xvec)_{|\xvec|-1})].\]

\begin{definition}
Let $F$ be free on a finite or  countable set $\{a_1,\ldots \}$. 
Then $F$ is \grz{3}-computable with respect to the index $(i,m,j)$ defined
in \eqref{al:ifree}, \eqref{eq:mfree} and \eqref{eq:jfree} above. This index is called the 
\emph{standard index} of $F$ (w.r.t $\{a_1,\ldots \}$).
\end{definition}
\section{Definition 3.3}
Let $G$ be a group with presentation $\langle X|R\rangle$, let $F=F(X)$ be the 
free group on $X$ and let $K$ be the normal closure of $R$ in $F(X)$. 
Assume that $X$ is countable or finite and   
let $(i,m,j)$ be the standard index of $F$ w.r.t. $X$. 
Define the predicate $E$ by
\begin{equation}
E(x,y)\iff x\in i(F)\wedge y\in i(F) \wedge m(j(x),y))\in i(K).
\end{equation}
Define the function $r$ by
\begin{equation}
r(x):=\min_y(y\le x \wedge E(x,y)).
\end{equation}
\begin{definition}
The \emph{standard index} of $G$, with respect to the presentation
$P:=\langle X| R\rangle$, is $(i_P,m_P,j_P)$, where
\begin{equation}
i_P:=ri,\: m_P:=rm\textrm{ and } j_P:=rj.
\end{equation}
The group $G$ is said to be \emph{\grz{n}(A) standard}, if there 
is a presentation $P$ for $G$ such that $(i_P,m_P,j_P)$ is a \grz{n}(A) computable index for $G$.
\end{definition}
\section{Theorem 3.4}
\begin{theorem}[\cite{Cannonito_1973}, Theorem 3.4]
Let $G$ be a finitely generated  \grz{n}(A) standard group and let
$Q:=\langle Y|S\rangle$ be a presentation for $G$, where $Y$ is finite. 
Then the standard index $(i_Q,m_Q,j_Q)$ for $G$ is \grz{n}(A) computable. 
\end{theorem}
\begin{proof}
As $G$ is a \grz{n}(A) standard group there is a presentation 
$P=\langle X|R\rangle$ for $G$ such that the index $(i_P,m_P,j_P)$ is
\grz{n}(A) computable. 

Let $(i,m,j)$ and $(i^\prime, m^\prime, j^\prime)$ be the standard indices
of $F(X)$ and $F(Y)$, respectively. 
Let $\pi_P$%:F(X)\maps G$ 
 and $\pi_Q$ be the canonical maps from $F(X)$ to
$G$ and from $F(Y)$ to $G$. As noted in \cite{Cannonito_1973} it suffices
to show that the map $\pi_Q$ is \grz{n}(A) computable with respect to
the indices $(i^\prime,m^\prime,j^\prime)$ and $(i_P,m_P,j_P)$. That is,
to show that the map $\hat\pi_Q:i^\prime(F(Y))\maps i_P(G)$, 
given by $\hat\pi_Q(i^\prime(w))=i_P(\pi_Q(w))$, where  $w\in F(Y)$, is 
\grz{n}(A) computable. 

Let $Y=\{y_1,\ldots, y_n\}$. The maps $\pi_P$ and $\pi_Q$ are surjective, so
for each $k$ we may choose $v_k\in F(X)$ such that $\pi_Q(y_k)=\pi_P(v_k)$. 
Let $M=\max\{i(v_k^\eps): k=1,\ldots n, \eps=\pm 1\}$. 
Now let $w=y_{k_0}^{\eps_0}\cdots y_{k_r}^{\eps_r}\in F(Y)$, with $y_{k_s}
\in Y$ and $\eps_s=\pm 1$. Then
\begin{align*}
\hat\pi_Q(i^\prime(w)) & = \i_P(\pi_Q(w))\\
&=i_P(\pi_Q(y_{k_0}^{\eps_0})\cdots\pi_Q(y_{k_r}^{\eps_r}))\\
&=i_P(\pi_P(v_{k_0}^{\eps_0})\cdots  \pi_P(v_{k_r}^{\eps_r})).%\\
%&=m_P(\ldots  m_P(\pi_P(v_{k_0}^{\eps_0}), \pi_P(v_{k_1}^{\eps_1})) \ldots
%, \pi_P(v_{k_r}^{\eps_r})).
\end{align*} 
%(That is 
The index of the product on the 3rd line is equal to the 
number obtained by $r$ applications of $m_P$, beginning with the 
leftmost pair. More precisely, define
\begin{align*}
\hat m_P(\xvec,0)&:=1 \textrm{ and }\\
\hat m_P(\xvec, n+1)&:= 
\begin{cases}
m_P(\hat m_P(\xvec,n),(\xvec)_{n+1})
& \textrm{ if } n+1< |\xvec|\\
\hat m_P(\xvec,n)& \textrm{ otherwise }
\end{cases}
\end{align*}
Then 
\[i_P(\pi_P(v_{k_0}^{\eps_0})\cdots  \pi_P(v_{k_r}^{\eps_r}))
= \hat m_P([i_P(\pi_P(v_{k_0}^{\eps_0})), \ldots ,
\i_P(\pi_P(v_{k_r}^{\eps_r}) ]).\]

As $(i_P,m_P,j_P)$ is a standard index we have
$\hat m_P(\xvec)\le M\concat \cdots \concat M$, ($r$ $\concat$'s)
so $\hat m_P\le p_{|w|}^{|w|(M+1)}$, and it follows that $\hat \pi_Q$ is
\grz{n}(A) computable.
\end{proof}

Note that in the statement of the theorem above it is not assumed that
the original standard index is defined with respect to a presentation
with a finite generating set. However, if the original generating set,
$X$ in the proof, is countably infinite, then
  since $G$ is finitely generated, we may may choose generating elements
$g_1,\ldots ,g_n$, and then $g_k$ is a word in finitely many elements of $X$,
for $k=1,\ldots ,n$. The union $X^\prime$ of these elements is enough to generate
$G$, and every word in $R$ can then be rewritten as a word over $X^\prime$, to
give a new presentation $\langle X^\prime|R^\prime\rangle$, with 
$X^\prime$ finite.
The standard index with respect to this presentation is now \grz{n}(A)
computable, by the Theorem. Thus, once we have the theorem, we may
 assume that if $G$ is a f.g. \grz{n}(A) standard group then it
has a \grz{n}(A) standard index with respect to  a presentation on
a finite generating set.  
\section{A slightly different version of Theorem \ref{B-thm:fgoagogcomp} from the 
B-S paper}
 
\begin{theorem} \label{thm:fgoagogcomp1}
Suppose we have $G = \fgoagog$, where $\Gamma$ has $\nu$ vertices. Suppose 
all the $G_v$ are \grz{n}-computable groups for $n \geq 3$. Assume all the edge groups are \grz{n}-decidable, and all the isomorphisms $\phi_e$ are \grz{n}-computable. Then $G$ has \grz{n+2}-decidable word problem. If the indices
for the vertex groups are standard then $G$ has \grz{n+1}-decidable 
word problem. 
\end{theorem}

\begin{proof}
	We will show that the word problem of $G$ is \grz{n+1}-decidable. We can assume that the vertex groups $G_v$ are disjoint, and that there is an \grz{n}-computable structure $(i_v,m_v,j_v)$ associated with 
each $G_v$. Let 
\[Y = \left( \bigcup_{v \in V}G_v \right) \cup \left( \bigcup_{e \in E}\{e\} \right).\] As $G$ is generated by $X$ it is also generated by $Y$. 

Encode the depth-first walk of the spanning tree $T$ as a G\"odel number $\tvec$ per Section \ref{B-encodetrees}. Then the vertex-parent function $\phi_{\tvec}$ is \grz{3}-computable. From now on each vertex group can be referred to by the integer label of the vertex it belongs to.



We will define $i(F(Y))$, an index of the free group on the generators $Y$ of 
$G$, and use that to decide the word problem of $G$. First, we must assign numbers to the generators of $G$. Let $i_Y(g)$ denote the number corresponding to the generator $g$. We will begin by using the first $\nu^2$ numbers to represent potential edges. For $0 \leq a,b \leq \nu - 1$ define $i_Y(e_{a,b}) := a \cdot \nu + b$.

For each vertex group $G_a$ and  each $g_a \in G_a$, define $i_Y(g_a) := \nu^2 + J(a,i_a(g_a))$.

Now that every generator has been given an integer label, $i(F(Y))$ works the same way as the ``standard'' free group index described in \cite[Lemma 3.1]{Cannonito_1973} -- elements of $F(Y)$ are freely-reduced words, encoded as G\"odel lists.
%
% First, compute $w' = \pi(w)$. We now need to split $w'$ into an admissible sequence $(a_0,e_1,\dots,e_n,a_n)$.

First we construct a function that, for each letter in $Y$, either
decides which vertex group it is in or if it is an edge letter. Assign to each element $y\in Y$ a code as follows: If $y$ belongs to $G_a$, then its code is $a$. If $y$ is an edge letter, then its code is $\operatorname{biggest}(\tvec)+1$. We can then define an \grz{3}-decidable equivalence relation $\approx$ on the indices of the elements of $Y$, whose equivalence classes correspond to the vertex groups plus one for the set of all edges. Define
\begin{equation}
\type(x):=
\begin{cases}
\operatorname{biggest}(\tvec)+1& \textrm{ if } x< \nu^2\\
L(x \psub \nu^2)& \textrm{ if } x\ge \nu^2
\end{cases}
\end{equation}
and 
\begin{equation}
x\approx y \iff \type(x)=\type(y).
\end{equation}
 As $\approx$ has finitely many equivalence classes, and they are all \grz{3}-decidable, $\approx$ is \grz{3}-decidable.

Given a word $w\in F(Y)$, we wish to decide whether $w =_G 1$. 
Each letter $w_i$ in $w$ can first be replaced by $\pi(w_i)$. When working on the encoded version of $w$, this process is \grz{3}-computable. By concatenating all of the $\pi(w_i)$ and then freely reducing, we will create an admissible word $w^\prime$ equivalent to $w$.
Again, it follows from \cite{Cannonito_1973} that this process is 
\grz{3}-computable. (This is the same argument as for the function $\hat m_P$
above.)

The next task is to split $w'$ into `syllables', or contiguous subwords. A syllable is either a single edge letter or a word from one of the vertex groups.

From now on, let $\wvec$ be an encoded admissible word.  We will explain how to construct an encoded admissible sequence for $\wvec$.

Define a function which gives the position of the start of the syllable to which $(\wvec)_i$ belongs:
\recur{
	\operatorname{backtrack}(\wvec,0) &:= 0, \\
	\operatorname{backtrack}(\wvec,i+1) &:= \begin{cases}
																					i+1	&	(\wvec)_{i+1} < \nu^2, \\
																					i+1	&	(\wvec)_i \not \approx (\wvec)_{i+1}, \\
																					\operatorname{backtrack}(\wvec,i)	&	(\wvec)_i \approx (\wvec)_{i+1}.
																				\end{cases}
}

The function $\operatorname{backtrack}$ is constructed from \grz{3}-computable operations and is bounded by $|\wvec|$, so is itself \grz{3}-computable.

Now, the start of the \nth syllable is given by:
\recur{
\operatorname{start}(\wvec,0) &:= 0, \\
\operatorname{start}(\wvec,n+1) &:= \min_{\operatorname{start}(\wvec,n)+1 \leq i < |\wvec|} (\operatorname{backtrack}(\wvec,i) \neq \operatorname{start}(\wvec,n)).
}

The number of syllables can be computed like so:
\begin{equation} \operatorname{numsyllables}(\wvec) = \min_{i < |\wvec|} ( \operatorname{start}(\wvec,i) = |\wvec|). \end{equation}

And now the \nth syllable itself can be found:
\begin{equation} \operatorname{syllable}(\wvec,n) = \wvec[\operatorname{start}(\wvec,n) \dots \operatorname{start}(\wvec,n+1)-1]. \end{equation}

The function $\operatorname{syllable}$ is constructed from \grz{3}-computable functions and is bounded by $\wvec$ so is \grz{3}-computable.

To decide if a syllable, which is a word on the elements of some vertex group $G_v$, belongs to an appropriate edge group, it must be rewritten using the original index and multiplication function $m_v$ of $G_v$ provided in the setup, which is an \grz{n} operation.  
More precisely, let $(i_v,m_v,j_v)$ be the
given index for $G_v$ and define
\begin{align*}
\hat m_v(x,0)&:=1 \textrm{ and }\\
\hat m_v(x, n+1)&:= 
\begin{cases}
m_v(\hat m_v(x,n),(x)_{n+1})
& \textrm{ if } n+1< |x|\\
\hat m_v(x,n)& \textrm{ otherwise }
\end{cases}
.
\end{align*}
In general we do not have a \grz{n} bound for this recursion, so 
$\hat m_v$ is \grz{n+1}-computable. If the indices for the $G_v$ are 
all standard then, as in the case of Theorem 3.4 of \cite{Cannonito_1973},
as $m_v$ is bounded by $\concat$,
$\hat m_v$ is bounded by an \grz{n} function and so in this case
$\hat m_v$ is \grz{n}-computable.

We can then use the conditions of Lemma \ref{B-trivialnormalform} to determine if $\wvec$, encoded as $\wvec' = (a_0,e_1, \dots, e_n, a_n)$, is trivial.

If $n=0$, then $\wvec^\prime=1 \Leftrightarrow a_0=1$, which is an \grz{n}-decidable question.

If $n>0$, then we need to find a sequence of the form $e^{-1}A_ee$ or $eB_ee^{-1}$. The first of these is given by
\begin{equation}\label{eq:syll}
\begin{split}
\EgpB(\wvec^\prime)&=
	\min_{i}\; ((i < \operatorname{numsyllables}(\wvec')-2)\wedge\\
		&  (\operatorname{syllable}(\wvec',i) = e \in E) \wedge \\
                & (\type(\operatorname{syllable}(\wvec',i+1))=v>\nu^2)\wedge\\
		& ( \hat m(\operatorname{syllable}(\wvec',i+1)) \in i_v(B_e)) \wedge \\ 
		& ( \operatorname{syllable}(\wvec',i+2) = j(\operatorname{syllable}(\wvec',i)) ) 
	)
\end{split} 
\end{equation}
where $j$ is the inverse of (the encoded) group $F(Y)$.  
Note that since the first syllable must be an edge letter, we can say the last syllable is the inverse of the first by checking its length is 1, then computing its inverse. We don't need to know how to compute the whole multiplication table to do this. 
Define $\EgpA$ analagously and then define
\begin{align*}
\Egp(\wvec^\prime)&\iff (\EgpA(\wvec^\prime)< \operatorname{numsyllables}(\wvec')-2)\\ &\wedge (\EgpB(\wvec^\prime)< \operatorname{numsyllables}(\wvec')-2). 
\end{align*}




If $\Egp(\wvec^\prime)=0$ then $\wvec$ is not trivial. Otherwise, 
if $\Egp(\wvec^\prime)=1$ and   $\EgpB(\wvec^\prime)=i$ with 
$\operatorname{syllable}(\wvec',i+1)=\bvec\in i_v(B_e)$
then 
we can replace 
$\wvec^\prime[i..i+2]$ with  
with $\hat \phi_e(\hat m(\bvec,|\bvec|))$, where $\hat \phi_e$ is the 
map induced on $\i(B_e)$ by $\phi_e$, and try again. 
In detail, (using an obvious notation for the syllables found in 
$A_e$ or $B_e$) define 
\begin{equation}
\operatorname{replace}(\wvec^\prime):=
\begin{cases}
\wvec^\prime & \textrm{ if } \neg\Egp(\wvec^\prime)\\ 
\wvec^\prime[0..i-1]\concat\\\phi_e(\hat m(\bvec,|\bvec|))\concat \\\wvec^\prime[i+3..|\wvec^\prime|-1]
 & \textrm{ if  } \EgpB(\wvec^\prime)=i<\EgpA(\wvec^\prime)\\
\wvec^\prime[0..i-1]\concat\\\phi_e^{-1}(\hat m(\avec,|\avec|))\concat \\\wvec^\prime[i+3..|\wvec^\prime|-1] & \textrm{ if } \EgpA(\wvec^\prime)=i
\end{cases}
\end{equation}
The new word is still admissible and has fewer syllables than the original one, so repeated applications of this process will eventually lead to a word of one syllable or a negative answer. 
That is $\wvec=1$ if and only if 
$\operatorname{replace}^{(|\wvec^\prime|)}(\wvec^\prime)=1$. As
$\operatorname{replace}$ is \grz{n+1}-computable  and this is a
recursion  the word problem $WP(G)$ is \grz{n+2}-decidable, and hence $G$ is \grz{n+2}-computable by Corollary \ref{B-wp-iff-group}. If the 
vertex groups have \grz{n}-standard presentations then $\operatorname{replace}$ is \grz{n+1}-computable and 
 so we may replace $n+2$ by $n+1$ in these conclusions.
\end{proof}

\bibliographystyle{alpha}
\bibliography{grzegorczyk}

\end{document}
